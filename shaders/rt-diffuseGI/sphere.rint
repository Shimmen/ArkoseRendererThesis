#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#include <shared/RTData.h>
#include <common.glsl>
#include <intersections.glsl>

layout(set = 1, binding = 4) buffer readonly SphereSets { RTSphere spheres[]; } sets[];

struct SphereHit {
	vec3 normal;
	uint materialIndex;
};

hitAttributeNV SphereHit hit;

void main()
{
	RTSphere sphere = sets[gl_InstanceCustomIndexNV].spheres[gl_PrimitiveID];

	vec3 rayOrigin = gl_WorldRayOriginNV;
	vec3 rayDirection = normalize(gl_WorldRayDirectionNV);

	vec3 sphereCenter = gl_ObjectToWorldNV * vec4(sphere.center, 1.0);

	// TODO: There is probably a faster way of doing this!s
	vec3 radiiPoint = gl_ObjectToWorldNV * vec4(sphere.center + vec3(sphere.radius, 0.0, 0.0), 1.0);
	float sphereRadius = distance(radiiPoint, sphereCenter);

	float t;
	if (raySphereIntersection(sphereCenter, sphereRadius, rayOrigin, rayDirection, t)) {
		vec3 hitPoint = rayOrigin + t * rayDirection;
		hit.normal = normalize(hitPoint - sphereCenter);
		hit.materialIndex = 0; // TODO!

		const uint hitKind = 0u;
		reportIntersectionNV(t, hitKind);
	}
}
