#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#include <shared/RTData.h>
#include <intersections.glsl>

// TODO: It would be nice to put this in the c++/glsl shared context
#include <half.glsl>
struct RTVoxelContourHalf {
	f16vec4 plane;
};

layout(set = 1, binding = 6) buffer readonly VoxelContours  { RTVoxelContourHalf contours[]; } sets[];
layout(set = 1, binding = 7, scalar) buffer readonly Voxels { RTAABB_packable aabbs[]; } aabbSets[];
layout(set = 1, binding = 8, scalar) buffer readonly ColorIdx { uint colorIndices[]; } colorSets[];

struct ContourHit {
    vec3 normal;
	uint colorIndex;
};

hitAttributeNV ContourHit hit;

void main()
{
	RTVoxelContourHalf contour = sets[gl_InstanceCustomIndexNV].contours[gl_PrimitiveID];

	vec4 plane = contour.plane;
	plane.w = -plane.w; // TODO: Fix in proxy gen!

	float t;
	if (rayPlaneIntersection(plane.xyz, plane.w, gl_ObjectRayOriginNV, gl_ObjectRayDirectionNV, t) && t >= gl_RayTminNV && t <= gl_RayTmaxNV) {
		vec3 hitPoint = gl_ObjectRayOriginNV + t * gl_ObjectRayDirectionNV;

		RTAABB_packable _aabb = aabbSets[gl_InstanceCustomIndexNV].aabbs[gl_PrimitiveID];
		vec3 aabbMin = vec3(_aabb.minX, _aabb.minY, _aabb.minZ);
		vec3 aabbMax = vec3(_aabb.maxX, _aabb.maxY, _aabb.maxZ);

		if (all(greaterThanEqual(hitPoint, aabbMin)) && all(lessThanEqual(hitPoint, aabbMax))) {
			hit.normal = normalize(gl_ObjectToWorldNV * vec4(plane.xyz, 0.0));
			hit.colorIndex = colorSets[gl_InstanceCustomIndexNV].colorIndices[gl_PrimitiveID];

			//float localT = t;
			//float globalT = distance(gl_WorldRayOriginNV, gl_ObjectToWorldNV * vec4(hitPoint, 1.0));
			//if (abs(globalT - localT) < 1e-3) { /* yes, this is actually true */ }

			reportIntersectionNV(t, 0u);
		}
	}
}
