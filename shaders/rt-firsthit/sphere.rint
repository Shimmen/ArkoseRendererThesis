#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#include <shared/RTData.h>
#include <shared/SphericalHarmonics.h>
#include <common.glsl>
#include <intersections.glsl>

// TODO: It would be nice to put this in the c++/glsl shared context
#include <half.glsl>
struct RTSphereHalf {
	f16vec3 center;
	half radius;
};

layout(set = 1, binding = 4) buffer readonly SphereSets { RTSphereHalf spheres[]; } sets[];
layout(set = 1, binding = 5) buffer readonly SphereSH { SphericalHarmonics SHs[]; } setSHs[];

struct SphereHit {
	vec3 color;
};

hitAttributeNV SphereHit hit;

void main()
{
	RTSphereHalf sphere = sets[gl_InstanceCustomIndexNV].spheres[gl_PrimitiveID];

	vec3 rayOrigin = gl_WorldRayOriginNV;
	vec3 rayDirection = normalize(gl_WorldRayDirectionNV);

	vec3 sphereCenter = gl_ObjectToWorldNV * vec4(sphere.center, 1.0);

	// TODO: There is probably a faster way of doing this!
	vec3 radiiPoint = gl_ObjectToWorldNV * vec4(sphere.center + vec3(sphere.radius, 0.0, 0.0), 1.0);
	float sphereRadius = distance(radiiPoint, sphereCenter);

	float t;
	if (raySphereIntersection(sphereCenter, sphereRadius, rayOrigin, rayDirection, t)) {
		vec3 hitPoint = rayOrigin + t * rayDirection;
		vec3 N = normalize(hitPoint - sphereCenter);

		SphericalHarmonics sh = setSHs[gl_InstanceCustomIndexNV].SHs[gl_PrimitiveID];
		vec3 color = sampleSphericalHarmonic(sh, N);

		hit.color = color;
		reportIntersectionNV(t, 0u);
	}
}
