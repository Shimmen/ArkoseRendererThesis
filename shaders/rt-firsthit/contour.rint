#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#include <shared/RTData.h>
#include <intersections.glsl>

layout(set = 1, binding = 6) buffer readonly VoxelContours  { RTVoxelContour contours[]; } sets[];
layout(set = 1, binding = 7, scalar) buffer readonly Voxels { RTAABB_packable aabbs[]; } aabbSets[];
layout(set = 1, binding = 8, scalar) buffer readonly ColorIdx { uint colorIndices[]; } colorSets[];

struct ContourHit {
	uint colorIndex;
};

hitAttributeNV ContourHit hit;

void main()
{

	RTVoxelContour contour = sets[gl_InstanceCustomIndexNV].contours[gl_PrimitiveID];

#if 1

	vec4 plane = contour.plane;
	plane.w = -plane.w;

	plane = transpose(mat4(gl_WorldToObjectNV)) * plane;

	float t;
	if (rayPlaneIntersection(plane.xyz, plane.w, gl_WorldRayOriginNV, gl_WorldRayDirectionNV, t) && t >= gl_RayTminNV && t <= gl_RayTmaxNV) {
		vec3 hitPoint = gl_WorldRayOriginNV + t * gl_WorldRayDirectionNV;

		// FIXME: To support arbitrary rotation we need to do something like this:
		//  http://dev.theomader.com/transform-bounding-boxes/, not just transform the corners.
		RTAABB_packable aabb = aabbSets[gl_InstanceCustomIndexNV].aabbs[gl_PrimitiveID];
		vec3 aabbMin = gl_ObjectToWorldNV * vec4(aabb.minX, aabb.minY, aabb.minZ, 1.0);
		vec3 aabbMax = gl_ObjectToWorldNV * vec4(aabb.maxX, aabb.maxY, aabb.maxZ, 1.0);

		if (all(greaterThanEqual(hitPoint, aabbMin)) && all(lessThanEqual(hitPoint, aabbMax))) {
			hit.colorIndex = colorSets[gl_InstanceCustomIndexNV].colorIndices[gl_PrimitiveID];
			reportIntersectionNV(t, 0u);
		}
	}

#else

	// FIXME: To support arbitrary rotation we need to do something like this:
	//  http://dev.theomader.com/transform-bounding-boxes/, not just transform the corners.
	RTAABB_packable aabb = aabbSets[gl_InstanceCustomIndexNV].aabbs[gl_PrimitiveID];
	vec3 aabbMin = gl_ObjectToWorldNV * vec4(aabb.minX, aabb.minY, aabb.minZ, 1.0);
	vec3 aabbMax = gl_ObjectToWorldNV * vec4(aabb.maxX, aabb.maxY, aabb.maxZ, 1.0);

	// Doesn't work, since gl_RayTminNV is not set relative to our AABB!
	//hit.normal = N;
	//reportIntersectionNV(gl_RayTminNV, 0u);

	// Does work, but that's just for testing..
	float tmin, tmax;
	if (rayAabbIntersection(aabbMin, aabbMax, gl_WorldRayOriginNV, gl_WorldRayDirectionNV, tmin, tmax)) {
		hit.colorIndex = colorSets[gl_InstanceCustomIndexNV].colorIndices[gl_PrimitiveID];
		if (tmin >= gl_RayTminNV && tmin <= gl_RayTmaxNV) {
			reportIntersectionNV(tmin, 0u);
		} else if (tmax >= gl_RayTminNV && tmax <= gl_RayTmaxNV) {
			reportIntersectionNV(tmax, 0u);
		}
	}

#endif
}
