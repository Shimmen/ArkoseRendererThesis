#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#include <shared/RTData.h>
#include <intersections.glsl>

layout(set = 1, binding = 6) buffer readonly VoxelContours  { RTVoxelContour contours[]; } sets[];
layout(set = 1, binding = 7, scalar) buffer readonly Voxels { RTAABB_packable aabbs[]; } aabbSets[];
layout(set = 1, binding = 8, scalar) buffer readonly ColorIdx { uint colorIndices[]; } colorSets[];

struct ContourHit {
	vec3 normal;
	uint colorIndex;
};

hitAttributeNV ContourHit hit;

void main()
{
	RTVoxelContour contour = sets[gl_InstanceCustomIndexNV].contours[gl_PrimitiveID];

#if 1

	vec4 plane = contour.plane;
	plane.w = -plane.w; // TODO: Fix in proxy gen!

	float t;
	if (rayPlaneIntersection(plane.xyz, plane.w, gl_ObjectRayOriginNV, gl_ObjectRayDirectionNV, t) && t >= gl_RayTminNV && t <= gl_RayTmaxNV) {
		vec3 hitPoint = gl_ObjectRayOriginNV + t * gl_ObjectRayDirectionNV;

		RTAABB_packable _aabb = aabbSets[gl_InstanceCustomIndexNV].aabbs[gl_PrimitiveID];
		vec3 aabbMin = vec3(_aabb.minX, _aabb.minY, _aabb.minZ);
		vec3 aabbMax = vec3(_aabb.maxX, _aabb.maxY, _aabb.maxZ);

		if (all(greaterThanEqual(hitPoint, aabbMin)) && all(lessThanEqual(hitPoint, aabbMax))) {
			mat3 normalMatrix = transpose(mat3(gl_WorldToObjectNV));
			hit.normal = normalize(normalMatrix * plane.xyz);
			hit.colorIndex = colorSets[gl_InstanceCustomIndexNV].colorIndices[gl_PrimitiveID];

			//float localT = t;
			//float globalT = distance(gl_WorldRayOriginNV, gl_ObjectToWorldNV * vec4(hitPoint, 1.0));
			//if (abs(globalT - localT) < 1e-3) { /* yes, this is actually true */ }

			reportIntersectionNV(t, 0u);
		}
	}

#else

	RTAABB_packable _aabb = aabbSets[gl_InstanceCustomIndexNV].aabbs[gl_PrimitiveID];
	vec3 aabbMin = vec3(_aabb.minX, _aabb.minY, _aabb.minZ);
	vec3 aabbMax = vec3(_aabb.maxX, _aabb.maxY, _aabb.maxZ);

	// Doesn't work, since gl_RayTminNV is not set relative to our AABB!
	//hit.normal = N;
	//reportIntersectionNV(gl_RayTminNV, 0u);

	// Does work, but that's just for testing..
	float tmin, tmax;
	if (rayAabbIntersection(aabbMin, aabbMax, gl_ObjectRayOriginNV, gl_ObjectRayDirectionNV, tmin, tmax)) {
		hit.colorIndex = colorSets[gl_InstanceCustomIndexNV].colorIndices[gl_PrimitiveID];
		if (tmin >= gl_RayTminNV && tmin <= gl_RayTmaxNV) {
			reportIntersectionNV(tmin, 0u);
		} else if (tmax >= gl_RayTminNV && tmax <= gl_RayTmaxNV) {
			reportIntersectionNV(tmax, 0u);
		}
	}

#endif
}
